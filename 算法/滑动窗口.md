[点这里查看一篇别人的优秀总结--滑动窗口](https://www.bookstack.cn/read/fucking-algorithm/算法思维系列-滑动窗口技巧.md)

[另一篇优秀的总结](https://blog.csdn.net/qq_43152052/article/details/102840715)

上面那篇文章既好理解又实用

>滑动窗口，或者叫双指针问题，一般找子串--总之就是一串字符中的某些字符有关的问题，都可以用该类方法解决。
>>何时使用滑动窗口呢，有关于一个长序列，去找序列自身的子序列的相关问题应该都可以考虑使用滑动窗口。所谓长序列就承担被遍历的工作，所要查找的字串内容就是在化身为一个window去在长序列里慢慢的查询直到找到所需要的内容。

核心在于
- 找到right停止移动和left停止移动的判断条件。
- 用unordered_map记录要查找或是比较的数组。

具体判断方法依具体而定。   

---

# leetcode
>记录一些leetcode里的题号

1. **3-无重复字符的最长子串**

   停止移动right条件：needs里任一元素个数大于1。此时就开始移动left直至减为小于等于1。

2. **76-最小覆盖子串**
   
   ```C++
        if(needs.count(c1)){
            windows[c1]++;
            if(windows[c1] == needs[c1])count++; 
        }
        /*  ...  */  
         while(count == needs.size()){}
   ```
   >停止right移动
   同时left开始移动的判定条件如上while语句，这里用needs.size()来判断而非t的size来判断的理由在于，unordered_map的size函数返回为容纳的元素数，即“AAAB”返回值为2，把三个A当为的一个。我们看count的增加条件为窗口内的元素数严格等于需求的元素数，即两个元素相等时，count才会+1，也就是说要求窗口内同时包含三个A（以AAAB为needs举例）时才会count+1；那么如果用t的size来判断的话就必须要求一经包含有AAAB中一个元素时count就+1，与上述判断条件不符。

   >也就是说这两个条件是一组的，若用t.size()来判断应该也是可以的，但要改变count++的if语句的条件。

3. **424-替换后的最长重复字符**
   >>这题我想得太天真了，实际上套用滑动窗口的解题要点，即找right停止/left移动，left停止的条件即可。

   ![QQ截图20200801195244.png](https://i.loli.net/2020/08/01/4lk985BJEdGb2RL.png)

   >>我最开始做的时候以为窗口长度在变化不好解决，现在发现前两题都在变的。。所谓右指针在移动嘛，看来我是头晕了。

   >现在开始说这个题的要点，何时停止拓展right边界呢，那显然是当k不够用--无法再替换字母时。k不够用时此时的窗口状态是怎么样的呢，此时窗口中有若干字符，为保证连续的字符越长，那么显然这个窗口中出现频次最高的字符不能被替换掉，也就是说当窗口中的所有字符个数减去出现频次最高的那个字符的频次若大于k，那就是溢出了。此时开始移动left`while(right-left+1 - count >k)`。所以为了记录出现字符的频次，用unordered_map来记录即可，还需要每添加一个字符就更新记录出现频次的count变量。` count = max(count,m[c1]);`

    ## ***突然想到的要点***

   顺便我发现分析right停止移动的一个方法可以为，去思考当停止移动right时是达到了什么条件，如这一题是k不够用，上一题是满足needs之类的；然后分析此时窗口中的其余字符串的状态是什么，比如这题就是分析当k不够用时，窗口内的字符状态然后去找到等价条件---窗口中的所有字符个数减去出现频次最高的那个字符的频次等于k。

4. 


---
