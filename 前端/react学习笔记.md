# react元素和组件

组件是react的核心结构，react是基于组件开发，将每一个版本由组件封装起来，通过组合组件来使用。

组件的返回值是一个react元素。

React 元素其实就是一个简单JavaScript对象，一个React 元素和界面上的一部分DOM对应，描述了这部分DOM的结构及渲染效果。

[参考资料](https://segmentfault.com/a/1190000014978057)

# 数据向下流动

[详见最后一段]（https://zh-hans.reactjs.org/docs/state-and-lifecycle.html）

我这里的理解是，state数据是流动的，改变的，但他只能传递给比他层级更低的组件，而不能直接传给父组件。如果想影响父组件，首先需要父组件提供一个监听函数来检测其子组件的state（就像下面setState那节提到的calculator提供一个函数给子组件监听state的改变，从而获得state值进行计算，也就是通过**回调函数**来监听子组件，然后逆向数据流，这里参考[react哲学](https://zh-hans.reactjs.org/docs/thinking-in-react.html)，下面react哲学也有说到），所以子组件是不能直接影响到父组件的。并且向下流动的值，其子组件是不会知道也不关心这个值究竟是state或者是props。

# 事件处理

创建组件时，内部的事件如果要使用this指针，需要用bind或者箭头函数来绑定。

[介绍了this指针和为什么要bind](https://juejin.cn/post/6844903605984559118)

# setState/状态提升

是由该方法对state的值进行改变，并申请回调函数执行。

setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。

[状态提升，这个可以多看看](https://zh-hans.reactjs.org/docs/lifting-state-up.html)

这里有一个地方说到
1. 在这些方法内部，Calculator 组件通过使用新的输入值与当前输入框对应的温度计量单位来调用 this.setState() 进而请求 React 重新渲染自己本身。
2. React 调用 Calculator 组件的 render 方法得到组件的 UI 呈现。温度转换在这时进行，两个输入框中的数值通过当前输入温度和其计量单位来重新计算获得。
3. React 使用 Calculator 组件提供的新 props 分别调用两个 TemperatureInput 子组件的 render 方法来获取子组件的 UI 呈现。

我的理解是，当setState调用时，会申请react对calculator的重新渲染，这时就会调用calculator的render方法，在这个时候由于temperature的值改变了，就会对几个const值进行重新计算，然后再调用input的render方法进行更新渲染。主要是setstate开始申请重新渲染这个点作为开始。

另外这个代码的设计，我的理解是，子组件input最好就只用来呈现数据，至于数据的计算最好就由父组件来完成。但是原始数据是在input中输入的，这里涉及到就是将数据从子组件传递给父组件，所以父组件应该提供一个方法来让子组件使用，当数据变化时调用，然后计算新的值。

>在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠**自上而下的数据流**，而**不是**尝试在不同组件间同步 state。

>虽然提升 state 方式比双向绑定方式需要编写更多的“样板”代码，但带来的好处是，排查和隔离 bug 所需的工作量将会变少。由于“存在”于组件中的任何 state，仅有组件自己能够修改它，因此 bug 的排查范围被大大缩减了。此外，你也可以使用自定义逻辑来拒绝或转换用户的输入。

注意这里提到的依靠**自上而下**，将平行的两个组件需要共同使用到的state数据**提升**到一个最近的父组件中，然后在父组件中进行操作，然后向下传递给子组件。对于“双向绑定”我理解的是两个平行关系的组件互相绑定使用数据，会造成麻烦。

>如果某些数据可以由 props 或 state 推导得出，那么它就不应该存在于 state 中。举个例子，本例中我们没有将 celsiusValue 和 fahrenheitValue 一起保存，而是仅保存了最后修改的 temperature 和它的 scale。这是因为另一个输入框的温度值始终可以通过这两个值以及组件的 render() 方法获得。这使得我们能够清除输入框内容，亦或是，在不损失用户操作的输入框内数值精度的前提下对另一个输入框内的转换数值做四舍五入的操作。

也就是说能推导出来的就不要存储在state中了（不是不存储，是不存储在state中），将state尽量精简。比如这里，我们是需要华氏温度和摄氏温度，但我们只需要知道一种温度的数值和单位，就能推出另一种了，没必要把全部都记录在state中。知道这些后再利用自上而下，由父组件将需要呈现的数据传递给子组件直接使用即可。

# React设计哲学

[讲述了如何根据UI设计、划分react组件](https://zh-hans.reactjs.org/docs/thinking-in-react.html)

0. **设计UI**
1. **划分组件过程**：先要设计好UI长什么样子，然后进行划分组件。如何划分呢，原则上应该根据功能来划分，一个组件负责一种功能（单一功能原则），同种功能的划分为一个组件（不要划分出多余的组件）。
2. **静态版本**：刚开始编写的时候可以选择自顶向下或是自底向上（当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。）。在编写静态版本时，应只使用props而不是用state（state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，你不会用到它。）
    0. **写在2、3之间的**：对于那些从api获得的数据，他们是不改变的，也就是该计入props的。看数据随不随时间改变，不是说“它会从api中进行更新，从而需要改变”，我们这里应该是说要关注的是前端交互部分，而不是关注与后端的交互。比如获得“篮球 88元”这一组数据，它也许会被后端的修改，从而获得的数据改变了，但它平时是不会改变的，是不会被用户或者谁在修改值的。当它从api中get到之后，它就不会随着时间的改变而改变了，它是固定的，所以应该是属于props的数据。
3. **确定State的最小且完整的表示**（就是state的变量要求个数最少且功能齐全）：这里就是上面那段说的：“state尽量精简”。如何做到这里，首先我们需要将整个界面中所有需要的数据列出来，然后自问自己三个问题：
    - 该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。
    - 该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。
    - 你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。
4. **确定state应该出现在哪里**：我们需要确定哪些组件拥有着state，这样来思考
    - 找到根据这个 state 进行渲染的所有组件。
    - 找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。
    - 该共同所有者组件或者比它层级更高的组件应该拥有该 state。
    - 如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。
5. **反向数据流**：这个在上面也有提到过，就是通过添加一个回调函数--由父组件提供给子组件，来监听子组件的state的变化，从而让父组件得知变化情况，从而做出改变。
>让我们重新梳理一下需要实现的功能：每当用户改变表单的值，我们需要改变 state 来反映用户的当前输入。由于 state 只能由拥有它们的组件进行更改，FilterableProductTable 必须将一个能够触发 state 改变的回调函数（callback）传递给 SearchBar。我们可以使用输入框的 onChange 事件来监视用户输入的变化，并通知 FilterableProductTable 传递给 SearchBar 的回调函数。然后该回调函数将调用 setState()，从而更新应用。

